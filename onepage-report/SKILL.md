---
name: onepage-report
description: 從素材資料夾產生一頁投影片 + 演講稿
arguments: [input_path]
---

# 一頁投影片產生器

> 版本：v2.5

將素材（資料夾/PPTX/URL）轉換成專業的一頁投影片與演講稿。

## 執行流程

### Phase 1：設定詢問

使用**一次** AskUserQuestion 工具，同時詢問以下 4 個問題：

```json
{
  "questions": [
    {
      "question": "這份報告需要什麼程度的佐證？",
      "header": "佐證",
      "multiSelect": false,
      "options": [
        {"label": "E0 使用現有數據 (預設)", "description": "不要求新實驗，使用素材中的現有數據"},
        {"label": "E1 輕佐證", "description": "需要 1-2 個關鍵指標（如 FPS、功耗）"},
        {"label": "E2 強佐證", "description": "需要完整實驗設計與數據"}
      ]
    },
    {
      "question": "需要幾輪審稿？",
      "header": "審稿",
      "multiSelect": false,
      "options": [
        {"label": "5 輪 (預設)", "description": "審稿→重寫→審稿，最多五輪"},
        {"label": "3 輪", "description": "審稿→重寫→審稿，最多三輪"},
        {"label": "自訂", "description": "輸入自訂次數"}
      ]
    }
  ]
}
```

使用者回答後，再**單獨詢問**報告目的（因為這是文字輸入）：

```json
{
  "questions": [
    {
      "question": "這份報告想要達成什麼？（範例：核准 POC、申請加人、採用方案 A、核准預算）",
      "header": "目的",
      "multiSelect": false,
      "options": [
        {"label": "核准 POC", "description": "請主管核准進行概念驗證"},
        {"label": "申請資源", "description": "申請人力、預算或設備"},
        {"label": "採用方案", "description": "建議採用特定技術方案"},
        {"label": "知會進度", "description": "報告專案進度或成果"}
      ]
    }
  ]
}
```

如果使用者在「審稿」選擇「自訂」，再追問具體次數。

記錄使用者的選擇：
- `PURPOSE`：報告目的
- `EVIDENCE`：E0 / E1 / E2
- `MAX_ITERATIONS`：正整數（預設 5）

---

### Phase 2：讀取素材

根據 `{input_path}` 判斷輸入類型並處理：

#### 2.1 判斷輸入類型

| 輸入格式 | 判斷條件 | 處理方式 |
|----------|----------|----------|
| 資料夾 | 路徑是目錄 | 掃描 .txt/.md/.pptx/.pdf 檔案 |
| PPTX 檔案 | 以 .pptx 結尾 | 使用 extract_pptx.py 抽取 |
| PDF 檔案 | 以 .pdf 結尾 | 使用 extract_pdf.py 抽取 |
| URL | 以 http:// 或 https:// 開頭 | 使用 WebFetch 抓取 |

#### 2.2 資料夾處理

1. 使用 Glob 工具掃描資料夾內的檔案：
   ```
   Glob: {input_path}/**/*.txt
   Glob: {input_path}/**/*.md
   Glob: {input_path}/**/*.pptx
   Glob: {input_path}/**/*.pdf
   ```

2. 對於 .txt/.md 檔案：使用 Read 工具讀取內容

3. 對於 .pptx 檔案：
   - 先詢問使用者要抽取哪些投影片
   - 執行 extract_pptx.py 抽取內容：
   ```bash
   python {skill_dir}/scripts/extract_pptx.py {pptx_file} ./temp_extract/ --slides "{slide_range}"
   ```
   - 讀取 ./temp_extract/text.md 作為素材

4. 對於 .pdf 檔案：
   - 先詢問使用者要抽取哪些頁面，是否需要 OCR
   - 執行 extract_pdf.py 抽取內容：
   ```bash
   python {skill_dir}/scripts/extract_pdf.py {pdf_file} ./temp_extract/ --pages "{page_range}" [--ocr]
   ```
   - 讀取 ./temp_extract/text.md 作為素材

#### 2.3 單一 PPTX 檔案處理

1. 先列出投影片清單讓使用者選擇：
   ```bash
   python {skill_dir}/scripts/extract_pptx.py {input_path} --list
   ```

2. 使用 AskUserQuestion 詢問：
   ```
   以下是 PPTX 的投影片清單：

   {slide_list}

   請輸入要抽取的投影片範圍：
   - 範例："1-5" 或 "1,3,5,7" 或 "1-3,7,10-12"
   - 留空表示全部抽取
   ```

3. 執行抽取：
   ```bash
   python {skill_dir}/scripts/extract_pptx.py {input_path} ./temp_extract/ --slides "{slide_range}"
   ```

4. 讀取 ./temp_extract/text.md 作為素材

#### 2.4 單一 PDF 檔案處理

1. 先列出頁面清單讓使用者選擇：
   ```bash
   python {skill_dir}/scripts/extract_pdf.py {input_path} --list
   ```

2. 使用 AskUserQuestion 詢問：
   ```
   以下是 PDF 的頁面清單：

   {page_list}

   請輸入要抽取的頁碼範圍：
   - 範例："1-5" 或 "1,3,5,7" 或 "1-3,7,10-12"
   - 留空表示全部抽取

   是否啟用 OCR？（適用於掃描文件）
   1. 否（預設）
   2. 是
   ```

3. 執行抽取：
   ```bash
   python {skill_dir}/scripts/extract_pdf.py {input_path} ./temp_extract/ --pages "{page_range}" [--ocr]
   ```

4. 讀取 ./temp_extract/text.md 作為素材

#### 2.5 URL 處理

1. 使用 WebFetch 工具抓取網頁內容：
   ```
   WebFetch: {input_path}
   prompt: 請抽取這個網頁的主要內容，包括標題、重點、數據等。忽略導覽列、廣告、頁尾等。
   ```

2. 將抓取的內容整理成素材格式

#### 2.5 整理素材

將所有來源的內容整理成統一格式：

```
=== 素材彙整 ===

--- 來源：{source1}（{type1}）---
{content1}

--- 來源：{source2}（{type2}）---
{content2}
```

其中 type 可以是：txt、md、pptx:slide=1-5、url

#### 2.6 建立 Citation Map

為每個素材段落建立 citation ID，方便追溯來源：

```markdown
## Citation Map

### C1
- **來源**：notes.md
- **位置**：第 1-5 行
- **原文**：Framepacing V2 透過SF queue來用部份延遲換部份功耗...

### C2
- **來源**：notes.md
- **位置**：第 6-10 行
- **原文**：傳統方法透過拉高 CPU 頻率來維持 99% 不掉幀率...

### C3
- **來源**：presentation.pptx:slide=3
- **位置**：shape 2
- **原文**：BufferTX 緩衝池可維持 0-3 個緩衝幀...
```

建立規則：
- 每個有實質內容的段落都給一個 citation ID（C1, C2, C3...）
- 記錄來源檔案、位置、原文摘要
- 後續 Phase 3 產出內容時引用這些 ID

#### 2.7 術語處理（國中生看不懂的詞）

讀取素材後，掃描是否有國中生看不懂的英文名詞或術語。

**識別目標：**
- 英文專有名詞（如：Click-to-Photon、Frame Pacing、Anti-Lag）
- 英文縮寫（如：FPS、SoC、NUMA、CCX）
- 技術術語（如：latency、buffer、pipeline、migration）
- 任何可能讓國中生困惑的詞

**處理流程：**

```
對於每個識別到的術語：

1. 先嘗試 WebSearch 查詢
   - 搜尋：「{術語} 是什麼 解釋」或「{術語} meaning explanation」
   - 如果找到清楚的解釋 → 記錄到術語清單，繼續使用

2. 如果 WebSearch 找不到或解釋不清楚
   - 使用 AskUserQuestion 詢問使用者：

   「素材中出現了 '{術語}'，這個詞國中生可能看不懂。
   請問：
   1. 這個詞的白話解釋是什麼？
   2. 或者，可以刪掉/改用其他說法嗎？」

3. 如果使用者也不知道或說可以刪掉
   - 從素材中移除該術語
   - 改用白話文描述（如果可以）
   - 或直接刪除該段落（如果無法改寫）
```

**術語清單格式：**

```markdown
## 術語處理清單

| 術語 | 處理方式 | 白話解釋 | 來源 |
|------|----------|----------|------|
| Click-to-Photon | 保留+解釋 | 從按下按鈕到畫面顯示的總延遲時間 | WebSearch |
| Frame Pacing | 保留+解釋 | 控制遊戲畫面輸出節奏的技術 | 使用者提供 |
| NUMA | 刪除 | - | 使用者說可刪 |
| latency | 改寫 | 改用「延遲」 | 直接翻譯 |
```

**重要原則：**
- 寧可多問，也不要留下看不懂的術語
- 如果術語對報告結論很重要，一定要找到解釋
- 如果術語不重要，可以直接刪掉或改用白話文
- 所有保留的術語都要加入 glossary.md

---

### Phase 3：產生初稿

根據素材內容與使用者設定，產生三到四份文件。

#### 3.1 產生 one_page.md

使用統一的完整格式，盡可能詳細說明。根據素材提取並整理內容：

```markdown
# {結論標題，<=100字，要有數字或明確結論}
{副標題：靈感來源或目標說明，<=160字}

## 已驗證的成功要素
{說明 PC/Server 平台或業界已驗證有效的前提條件}
- {要素 1，<=120字} [C1]
- {要素 2，<=120字} [C2]
- {要素 3，<=120字} [C3]
- {已驗證的效果，含具體數字} [C4]

## 現況與問題
{說明目前平台（如 Dimensity）的現況與瓶頸}
- {現況/問題 1，<=120字} [C5]
- {現況/問題 2，<=120字} [C6]
- {現況/問題 3，<=120字} [C7]

## 技術關鍵點 / 為何可能有效
{說明為何在手機平台可能有類似效果}
- {關鍵點 1，<=120字} [C8]
- {關鍵點 2，<=120字} [C9]
- {推論結論，<=160字} [C10]

## 對照表（可選）
| 比較項目 | PC 平台 | 手機平台 |
|----------|---------|----------|
| {項目1}  | {PC做法} | {手機做法} |
| {項目2}  | {PC做法} | {手機做法} |

## 預期效益
- {效益 1，量化優先，<=120字}
- {效益 2，<=120字}
- {效益 3，<=120字}

## POC 設計
實驗條件：
- A 組 (Baseline)：{現行方案}
- B 組 (Experimental)：{新方案}

遊戲場景：
- {場景 1}
- {場景 2}

## 成功判定準則
1. {判定項目 1}
   {具體指標與門檻}
2. {判定項目 2}
   {具體指標與門檻}
3. {判定項目 3}
   {具體指標與門檻}

## 行動
{決策建議，<=160字，需符合報告目的，可包含時程/條件}
```

**內容密度原則（MTK 風格）：**
- 一頁投影片要有足夠資訊量，讓主管能做決策
- 每個 bullet 都要有實質內容，不要空泛
- 數字要具體（不要「大幅改善」，要「改善 81%」）
- 可以有 3-4 個 bullet，不用限制只有 2 個
- 要有「已驗證」→「現況問題」→「為何可行」→「POC 設計」→「成功判定」的邏輯鏈

**區塊可根據內容彈性調整：**
- 如果不是技術 POC 題目，可以省略「已驗證的成功要素」
- 如果沒有對照需求，可以省略「對照表」
- 核心區塊：標題、現況/問題、證據/效益、行動

**撰寫原則（國中生能懂標準）：**

- 所有內容必須讓國中生能看懂
- **優先使用白話文**，盡可能詳細解釋
- **只有字數太多時**才改用術語，並加 `[[術語]]` 標記連結到附錄
- 術語標記會自動連結到附錄的白話解釋 + 圖解說明
- 寧可多寫幾句白話文，也不要為了精簡而用看不懂的術語

**標題撰寫原則：**
- 必須是結論句，不是主題句
- 好：「導入快取可降低 80% 回應時間」
- 壞：「系統效能改善方案」

#### 3.1.5 圖表內容識別

在產生圖表前，先掃描素材識別**所有**可視覺化的內容。目標是盡可能多地生成流程圖和對比圖。

**識別規則：**

| 內容類型 | 識別關鍵詞 | 圖表類型 |
|----------|-----------|---------|
| 改善對比 | 改善、優化、問題→解決、Before/After、降低、提升、消除 | `before_after` |
| 平台對比 | PC、手機、Android、iOS、平台、差異、對照表、vs | `platform_compare` |
| 流程步驟 | 步驟、流程、鏈路、pipeline、→、然後、接著、管線 | `flow` |
| 時間序列 | 延遲、latency、時序、從...到...、全鏈路、Input-to-Display | `timeline` |

**識別流程：**

1. 逐段掃描素材，尋找符合上述關鍵詞的段落
2. 特別注意：
   - 素材中的**對照表**（通常是 PC vs 手機的對比）
   - 描述**問題→解決方案**的段落
   - 描述**技術流程或鏈路**的段落
3. 為每個識別到的內容記錄：類型、來源、關鍵元素、與結論的關聯性

**識別輸出格式（內部使用）：**

```markdown
## 識別到的可視覺化內容

### V1：{內容標題}
- **類型**：before_after
- **來源**：素材第 X 段 / 對照表
- **關鍵元素**：
  - Before: {問題狀態}
  - After: {改善狀態}
- **與結論關聯**：高/中/低
- **建議位置**：主圖 / 附錄

### V2：{內容標題}
- **類型**：platform_compare
- **來源**：素材對照表
- **關鍵元素**：
  - 平台 A: {機制/流程}
  - 平台 B: {機制/流程}
  - 關鍵差異: {差異點}
- **與結論關聯**：高/中/低
- **建議位置**：主圖 / 附錄

### V3：...
```

**強制圖表要求（必須產生）：**

| 位置 | 必須圖表 | 類型 | 說明 |
|------|----------|------|------|
| **主投影片** | 前後比較圖 | `before_after` | 必須有！展示改善前 vs 改善後的差異 |
| **附錄** | 系統架構圖 | `architecture` | 必須有！展示整體系統/技術架構 |
| **附錄** | 流程比較圖 | `platform_compare` | 如有參考 PC/其他平台/方法，必須有！ |

**主投影片 - 前後比較圖（必須）：**
- 每份報告的主投影片都必須有一張前後比較圖
- 左側：改善前的問題/現況（用紅色標示問題點）
- 右側：改善後的效果（用綠色標示改善點）
- 中間：標註導入的方案和效果數據

**附錄 - 系統架構圖（必須）：**
- 每份報告的附錄都必須有一張系統架構圖
- 展示整體技術架構、模組關係、資料流向
- 用顏色標示本次改動影響的部分
- 讓讀者理解「這個改動在系統的哪個位置」

**附錄 - 流程比較圖（條件必須）：**
- 如果技術發想來自 PC 平台、其他平台、或參考其他方法
- 必須產生流程比較圖，展示：
  - 原始平台/方法的流程
  - 本次方案的流程
  - 兩者的差異和為何需要調整

**額外圖表（根據內容產生）：**
- 時間軸圖（如有延遲分析）
- 實驗流程圖（如有補充實驗）
- 其他可視覺化的內容
- **附錄圖數量無上限**，有多少可視覺化內容就畫多少

---

#### 3.2 產生 diagrams.md

根據 3.1.5 識別的內容，產生**多張圖表**。檔名為 `diagrams.md`（複數形式）。

**diagrams.md 格式：**

````markdown
# 圖表集

## 主圖：{圖表標題}

- **類型**：{before_after | platform_compare | flow | timeline}
- **說明**：{一句話說明這張圖要表達什麼}
- **尺寸**：{根據內容量：960x480 / 800x400 / 640x320}

### SVG 生成指示

{詳細描述圖表內容的自然語言提示詞}

包含：
1. 整體佈局（左右對比/上下排列/線性流程）
2. 各元素內容與位置
3. 箭頭/連線關係
4. 顏色標示（紅=問題、綠=解決）
5. 要顯示的文字標籤

---

## 附錄圖 1：{圖表標題}

- **類型**：{類型}
- **說明**：{說明}
- **尺寸**：1056x461（單圖）/ 1152x202（兩圖）/ 605x202（2x2）

### SVG 生成指示

{自然語言描述}

---

## 附錄圖 2：{圖表標題}

- **類型**：{類型}
- **說明**：{說明}
- **尺寸**：605x202

### SVG 生成指示

{自然語言描述}

（依此類推，有多少就畫多少）
````

**尺寸規格：**

| 位置 | 尺寸（像素） | 說明 |
|------|-------------|------|
| 主圖 | 動態（見下表） | 根據內容量決定 |
| 附錄單圖 | 1056×461 | 附錄頁只有一張圖時 |
| 附錄兩圖 | 1152×202 | 附錄頁有兩張圖時 |
| 附錄 2x2 | 605×202 | 附錄頁有 3-4 張圖時 |

**主圖尺寸選擇**（根據主投影片內容量）：

| 主投影片內容量 | 主圖尺寸 |
|---------------|---------|
| 少（≤3 區塊） | 960×480 |
| 中（4 區塊） | 800×400 |
| 多（≥5 區塊） | 640×320 |

**圖表類型與 SVG 生成指示：**

---

**1. before_after（前後對比）- 最高優先作為主圖**

適用：改善效果、問題解決前後對比

````markdown
### SVG 生成指示

生成「前後對比」圖表，左右並排佈局，**要畫出詳細的內部流程**：

**左側區塊「改善前」**（紅色邊框 #F44336，淺灰背景 #F5F5F5）：
- 標題：❌ 改善前：{具體問題名稱}
- 內部要畫出完整流程，每個節點包含：
  1. {具體步驟名稱}
     - 說明：{這步驟做什麼}
     - 問題：{這裡有什麼問題}（用紅色標示）
     - 數據：{相關數據，如延遲時間}
  2. {下一個步驟}...
- 用紅色虛線標出問題發生的位置
- 在問題點旁邊加上說明文字

**右側區塊「改善後」**（綠色邊框 #4CAF50，淺灰背景 #F5F5F5）：
- 標題：✅ 改善後：{改善方案名稱}
- 內部畫出改善後的流程：
  1. {步驟名稱}
     - 改變：{這裡改變了什麼}（用綠色標示）
     - 效果：{改善後的數據}
  2. {下一個步驟}...
- 用綠色標示改善的部分

**中間連接**：
- 虛線箭頭從左區塊指向右區塊
- 箭頭上方標註：「導入 {方案名稱}」
- 下方標註：「效果：{具體改善數據}」

**底部總結**：
- 加入對比數據表格或重點總結
````

---

**2. platform_compare（平台對比）**

適用：PC vs 手機、不同平台機制對照。**這是處理 PC/手機對比的專用類型。**

````markdown
### SVG 生成指示

生成「平台對比」圖表，上下並排佈局，**每個平台都要有完整的內部流程**：

**上方區塊「PC 平台」**（藍色邊框 #2196F3）：
- 標題：🖥️ PC 平台：{機制名稱}
- 完整流程（橫向）：
  1. [{步驟1名稱}]
     └ {具體做什麼}
     └ {時間或數據}
  → 2. [{步驟2名稱}]
     └ {具體做什麼}
     └ {時間或數據}
  → 3. [{結果}]
     └ {達成效果}
- 每個節點內要有 2-3 行說明

**下方區塊「手機平台」**（藍色邊框 #2196F3）：
- 標題：📱 手機平台：{機制名稱}
- 完整流程（橫向），結構同上
- 用不同顏色標示跟 PC 不同的步驟

**差異標註**（用橙色虛線 #FF9800）：
- 連接兩平台的對應步驟
- 每個差異點都要有說明文字：
  - 「PC：{PC的做法}」
  - 「手機：{手機的做法}」
  - 「差異原因：{為什麼不同}」

**右側或底部總結區**：
- 關鍵差異列表
- 為什麼手機要用不同做法
````

設計原則：
- 上下顯示兩個平台的完整流程
- 每個節點都要有具體內容，不只是名稱
- 用虛線箭頭標註關鍵差異點 + 說明文字
- 每個平台的步驟要對齊（方便對照）

---

**3. flow（流程圖）**

適用：單一流程、步驟說明、機制運作

````markdown
### SVG 生成指示

生成「流程圖」，橫向線性佈局，**每個節點都要有詳細說明**：

**節點序列**（藍色圓角矩形 #2196F3）：

1. [{開始：觸發條件}]
   ├ 觸發方式：{什麼情況會觸發}
   └ 輸入：{需要什麼輸入}

   ↓ {條件或數據}

2. [{步驟1名稱}]
   ├ 動作：{具體做什麼}
   ├ 處理：{怎麼處理}
   └ 耗時：{時間}

   ↓ {輸出什麼}

3. [{步驟2名稱}]
   ├ 動作：{具體做什麼}
   └ 注意：{重要事項}

   ↓

4. [{結果}]
   ├ 輸出：{產生什麼}
   └ 效果：{達成什麼效果}

**連接方式**：
- 節點間用實線箭頭連接
- 箭頭上標註：條件、數據、或輸出內容
- 如有分支，要畫出判斷菱形和多條路徑
````

---

**4. timeline（時間軸/延遲鏈路）**

適用：延遲分析、時序關係、Input-to-Display 鏈路

````markdown
### SVG 生成指示

生成「時間軸」圖表，橫向佈局，**每個階段都要有時間和說明**：

**時間軸線**：水平線貫穿整張圖，標註總時間

**事件節點**（沿時間軸分佈，每個節點要詳細）：

1. 🔴 [{起點事件}]（粉紅色 #E91E63）
   ├ 時間點：T=0
   └ 說明：{發生什麼}

   ──[{階段1名稱}: {時間}ms]──→
   　　└ {這段時間在做什麼}
   　　└ {瓶頸？原因？}

2. ⚪ [{中間事件1}]（灰色）
   ├ 時間點：T={累計時間}
   └ 說明：{發生什麼}

   ──[{階段2名稱}: {時間}ms]──→
   　　└ {這段時間在做什麼}

3. ⚪ [{中間事件2}]（灰色）
   ...

4. 🟢 [{終點事件}]（綠色 #4CAF50）
   ├ 時間點：T={總時間}
   └ 說明：{最終結果}

**時間標註**：
- 每個箭頭上標註該階段的時間
- 用紅色標示瓶頸階段（最耗時的部分）
- 底部加入時間總結：「總延遲：{X}ms，瓶頸在：{階段名}」

**額外資訊區**：
- 各階段時間佔比圖（可選）
- 優化建議（可選）
````

設計原則：
- 每個事件節點都要有時間和說明
- 箭頭上標註該階段的耗時
- 用顏色區分起點、中間、終點
- 用紅色標示瓶頸區段
- 底部加入總結

---

**5. architecture（系統架構圖）- 附錄必須**

適用：展示整體系統架構、模組關係、本次改動位置

````markdown
### SVG 生成指示

生成「系統架構圖」，展示完整的技術架構，**標示本次改動的位置**：

**整體佈局**：分層架構（上到下）或模組架構（左到右）

**分層架構範例**（上到下）：

┌─────────────────────────────────────────────────┐
│  📱 應用層 (Application Layer)                    │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │ 遊戲App  │  │ 系統UI   │  │ 其他App  │       │
│  └──────────┘  └──────────┘  └──────────┘       │
└─────────────────────────────────────────────────┘
                      ↓ API 呼叫
┌─────────────────────────────────────────────────┐
│  ⚙️ 框架層 (Framework Layer)                     │
│  ┌──────────┐  ┌──────────────────┐             │
│  │ Surface  │  │ 🔴 本次改動模組  │ ← 用顏色標示 │
│  │ Flinger  │  │ (詳細說明改了啥) │             │
│  └──────────┘  └──────────────────┘             │
└─────────────────────────────────────────────────┘
                      ↓ 系統呼叫
┌─────────────────────────────────────────────────┐
│  🔧 核心層 (Kernel Layer)                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │ 排程器   │  │ 記憶體   │  │ 驅動程式 │       │
│  └──────────┘  └──────────┘  └──────────┘       │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│  💾 硬體層 (Hardware Layer)                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │ CPU      │  │ GPU      │  │ Display  │       │
│  └──────────┘  └──────────┘  └──────────┘       │
└─────────────────────────────────────────────────┘

**每個模組要包含**：
- 模組名稱
- 簡短說明（這個模組做什麼）
- 如果是本次改動的模組，要：
  - 用橙色或紅色邊框標示
  - 加上「🔴 本次改動」標籤
  - 說明改動內容

**連線說明**：
- 箭頭標註資料流向
- 箭頭旁標註：傳遞什麼資料、呼叫什麼 API

**右側或底部說明區**：
- 本次改動影響範圍
- 為什麼要在這個位置改
- 對上下游的影響
````

設計原則：
- 展示完整架構，讓讀者理解全貌
- 用顏色突出本次改動的位置
- 每個模組都要有名稱和說明
- 標註資料流向和 API 呼叫關係
- 說明改動對系統的影響

---

**圖表設計通用原則（詳細優先）：**

- **詳細程度優先於簡潔**：寧可圖大一點，也要把細節畫清楚
- 每個節點要有**具體內容**，不要只寫「步驟1」「步驟2」
- 使用 emoji 區分狀態（✅❌⚠️🖥️📱🔵🟢🔴）
- 關鍵差異/問題點用虛線標註 + 文字說明
- 圖表要能**獨立閱讀**，不看報告也能懂
- 標題要說明圖的重點和結論

**詳細程度要求：**

| 層級 | 說明 | 範例 |
|------|------|------|
| ❌ 太簡略 | 只有抽象名稱 | 「步驟1 → 步驟2 → 結果」 |
| ⚠️ 不夠詳細 | 有名稱但沒說明 | 「觸控 → 渲染 → 顯示」 |
| ✅ 足夠詳細 | 有具體內容和數據 | 「觸控事件 (5ms) → GPU渲染一幀畫面 (12ms) → 螢幕顯示 (8ms)」 |
| ✅✅ 非常詳細 | 有子步驟和註解 | 每個節點內部還有 2-3 個子項目說明 |

**節點內容要求：**
- 每個節點要包含：名稱 + 說明或數據
- 如果有時間/數值，要標註在節點上
- 如果有條件/分支，要畫出來
- 差異點要用不同顏色標示

---

**SVG 生成規範：**

使用 Task 工具調用 subagent 生成 SVG 時，prompt 須包含以下規範：

```
## 基本規格
- viewBox: "0 0 {width} {height}"（從尺寸欄位取得）
- 白色背景矩形
- 字型：font-family="Microsoft JhengHei, Arial, sans-serif"
- 圖要畫滿整個 viewBox，不要留太多空白

## 文字大小
- 圖表標題：font-size="24"
- 區塊標題：font-size="18"
- 節點主文字：font-size="14"
- 節點說明文字：font-size="12"
- 標籤/註解：font-size="11"
- 數據/數值：font-size="13" + 粗體

## 配色
| 用途 | 顏色 | Hex |
|------|------|-----|
| 正面/改善後 | 綠 | #4CAF50 |
| 負面/改善前 | 紅 | #F44336 |
| 中性/流程 | 藍 | #2196F3 |
| 重點標示 | 橙 | #FF9800 |
| 區塊背景 | 淺灰 | #F5F5F5 |
| 邊框 | 深灰 | #BDBDBD |
| 文字 | 深灰 | #333333 |
| 次要文字 | 灰 | #757575 |

## 圖表結構
- before_after：左右兩個圓角矩形，中間虛線箭頭，每個矩形內部要有詳細流程
- platform_compare：上下兩個區塊，每個區塊內要有完整流程，用虛線標註差異
- flow：橫向連接的節點，每個節點要有說明文字，箭頭上要標註條件或數據
- timeline：時間軸線，每個事件要有時間標註和說明
- experiment_flow：對照組 vs 實驗組的完整比較圖
- architecture：分層或模組架構圖，標示本次改動位置

## 詳細程度檢查
生成前確認：
1. 每個節點都有具體內容（不只是名稱）
2. 數據和時間都有標註
3. 差異點都有標示
4. 圖例或說明完整
```

**範例：antilag2 素材應產生的圖表**

根據 antilag2 素材（參考 PC Anti-Lag 技術），應識別並產生以下圖表：

| 圖表 | 類型 | 位置 | 必須？ | 內容 |
|------|------|------|--------|------|
| 主圖 | before_after | 主投影片 | ✅ 必須 | Frame Queue 堆積 → SDK 同步後消除 |
| 附錄圖 1 | architecture | 附錄 | ✅ 必須 | Android 圖形系統架構，標示 SDK 插入位置 |
| 附錄圖 2 | platform_compare | 附錄 | ✅ 必須 | PC Anti-Lag vs 手機方案的流程對照 |
| 附錄圖 3 | timeline | 附錄 | 建議 | Input-to-Display 完整延遲鏈路 |
| 附錄圖 4 | flow | 附錄 | 建議 | BufferQueue 緩衝機制詳細流程 |
| 附錄圖 5 | experiment_flow | 附錄 | 如有實驗 | POC 實驗 A/B 組設計 |

**強制圖表檢查清單：**
- [x] 主圖有前後比較圖？
- [x] 附錄有系統架構圖？
- [x] 有參考 PC 平台，附錄有流程比較圖？

#### 3.3 產生 table.md（如有數據比較時）

當素材中包含數據比較（Before/After、多方案對比、指標比較）時，產生表格：

**判斷是否需要表格：**
- 素材中有 Before/After 數據
- 素材中有多個方案的指標比較
- 素材中有時間序列的變化數據
- 使用者設定 E1/E2（需要實驗數據）

**table.md 格式：**

```markdown
## 指標比較表

| Metric | Baseline | Experimental | Delta | 說明 |
|--------|----------|--------------|-------|------|
| FPS_avg | 60 fps | 66 fps | +10% | 平均幀率提升 |
| FPS_1%low | 45 fps | 52 fps | +16% | 最低幀更穩定 |
| Power | 900 mW | 820 mW | -9% | 功耗降低 |
| Jank | 15 次 | 3 次 | -80% | 掉幀大幅減少 |

**測試條件**：
- 裝置：Dimensity 9300
- 場景：原神璃月港
- 時長：120 秒
```

**表格設計原則：**
- 欄位數量：4-6 欄（太多會擠）
- 行數：3-8 行（太多考慮分組）
- Delta 欄：自動計算，顯示百分比或差值
- 重要數據可用粗體標示

#### 3.4 產生 glossary.md（術語詞彙表）

掃描 one_page.md 中的專業術語，用**國中生能懂**的方式產生術語解釋。

**識別原則（國中生能懂標準）：**

任何國中生可能看不懂的詞都要解釋，包括但不限於：
- 所有英文縮寫（CPU、FPS、POC、SoC 等）
- 技術術語（快取、延遲、吞吐量、cluster、migration 等）
- 專業名詞（任何需要專業背景才能理解的詞）
- 數字指標（需解釋數字代表什麼意義）

**術語分類：**

| 類別 | 範例 | 解釋重點 |
|------|------|----------|
| 架構術語 | cluster、L2 cache、NUMA | 是什麼、在系統中的角色 |
| 指標術語 | FPS、1% Low、Jank、latency | 代表什麼、為何重要 |
| 機制術語 | migration、scheduling、cache miss | 怎麼運作、影響什麼 |
| 縮寫 | POC、SoC、CCX | 全名、簡單解釋 |

**glossary.md 格式：**

```markdown
## 術語詞彙表

本報告中的專業術語解釋，適合非技術背景讀者參考。

### G1: {術語名稱}
- **類別**：{架構/指標/機制/縮寫}
- **白話解釋**：{用國中生能懂的方式解釋，可多句，<=200字}
- **在本報告的角色**：{<=150字，為何這個術語重要，與報告主題的關聯}
- **類比說明**（可選）：{<=100字，用日常生活類比幫助理解}

### G2: {術語名稱}
- **類別**：{類別}
- **白話解釋**：{<=200字}
- **在本報告的角色**：{<=150字}
- **類比說明**（可選）：{<=100字}

### G3: ...
```

**範例：**

```markdown
### G1: L2 Cache
- **類別**：架構術語
- **白話解釋**：處理器裡面有一塊特別快的暫存記憶體，叫做 L2 Cache。你可以想像處理器在做計算的時候，需要從記憶體拿資料。但主記憶體太遠了，拿一次要等很久。所以處理器旁邊放了一塊小但超快的記憶體，把常用的資料先存在這裡，下次要用就不用跑遠路了。
- **在本報告的角色**：當程式被搬到另一組處理器核心時，原本存在 L2 Cache 的資料就沒了，要重新從主記憶體抓，這會讓速度變慢。我們要解決的就是這個問題。
- **類比說明**：像是書桌上的常用文件，比去檔案櫃拿快很多

### G2: 1% Low FPS
- **類別**：指標術語
- **白話解釋**：FPS 是「每秒顯示幾張畫面」，數字越高畫面越流暢。但光看平均值會被騙，因為就算平均 60 FPS，中間偶爾掉到 20 FPS 你還是會感覺卡頓。所以我們特別看「最差的那 1% 時間的 FPS」，這個數字越高，代表遊戲越不會突然卡一下。
- **在本報告的角色**：我們的改善目標是提升 1% Low FPS，讓遊戲在最差情況下也不會太卡
- **類比說明**：就像開車，平均時速 60 不代表順暢，如果偶爾塞車掉到 10，體驗還是很差

### G3: Cluster Migration
- **類別**：機制術語
- **白話解釋**：手機處理器裡面有好幾組核心（叫做 cluster），有的省電但慢，有的耗電但快。作業系統會根據工作量，把程式從一組核心搬到另一組，這個動作叫做 migration。問題是搬家的時候，原本核心旁邊存的資料（cache）就帶不走，要重新載入，會浪費時間。
- **在本報告的角色**：頻繁的 migration 會導致 cache 一直失效，拖慢遊戲速度。我們的方案就是要減少不必要的搬移。
```

**產生規則：**

1. 掃描 one_page.md 中所有可能的專業術語
2. 識別所有國中生可能看不懂的詞（標準從嚴）
3. **用「國中生能懂」的白話文解釋每個術語**
   - 不要假設讀者有任何技術背景
   - 可以用多句話，把來龍去脈講清楚
   - 先說「是什麼」，再說「為什麼重要」
   - 避免用另一個專業術語來解釋
4. 標記術語在報告中首次出現的位置（用於後續超連結）
5. 術語數量：通常 3-8 個，不超過 10 個

**術語標記：**

在 one_page.md 中，用 `[[術語]]` 標記需要解釋的術語：

```markdown
## 技術關鍵點
- 降低跨 [[cluster]] 的 [[migration]]，可減少 [[L2 cache]] miss
- 預估可改善 [[1% Low FPS]] 達 15%
```

這些標記會在 Phase 6 渲染時轉換為超連結。

---

#### 3.5 產生 script.md

演講稿，每段標註要看投影片的哪個區塊。

**核心原則：金字塔式邏輯承接**

演講稿必須遵循金字塔原理，確保：
1. **一句承接一句**：每一句話都要承接上一句，不能跳躍
2. **邏輯不斷鏈**：從開場到結論，每一步推論都有明確依據
3. **結論是總結**：最後的結論必須是前面所有論述的邏輯總結

**邏輯承接範例：**
```
❌ 錯誤（跳躍）：
「目前 GPU 利用率只有 60%。建議導入 Framepacing V2。」
→ 為什麼利用率低就要導入這個技術？缺少中間推論

✓ 正確（承接）：
「目前 GPU 利用率只有 60%，代表有 40% 的運算資源被浪費。
這是因為遊戲引擎提交工作的時機不穩定，導致 GPU 空等。
Framepacing V2 透過預測下一幀完成時間，讓 GPU 提前準備，
實測可將利用率提升到 85%。因此建議導入此技術。」
→ 每一句都承接上一句，邏輯完整
```

**演講稿結構：**

```markdown
## 開場（看 TITLE）
{開場白，說明報告主旨，2-3 句}
{承接詞：「為什麼這很重要？讓我從背景說起...」}

## 說明背景（看 背景）
{背景說明，為什麼要做這件事，2-3 句}
{承接詞：「具體來說，流程是這樣的...」}

## 說明流程/變化（看 DIAGRAM）
{解釋圖表，說明流程或前後差異，3-4 句}
{承接詞：「這樣做的效果，我們有數據佐證...」}

## 關鍵數據（看 證據）
{說明證據與數據來源，2-3 句}
{承接詞：「這些數據代表什麼影響呢？」}

## 影響說明（看 影響）
{說明這樣做的影響，2-3 句}
{承接詞：「綜合以上分析...」}

## 結論（看 行動）
{總結：把前面所有論點串成一句邏輯總結}
{行動：說明需要的決策，呼應報告目的}
```

**結論撰寫要點：**
- 結論必須是前面所有段落的邏輯總和
- 格式：「因為 {背景問題}，透過 {方法/流程}，我們驗證了 {數據證據}，可達成 {影響效益}，因此建議 {行動}」
- 聽眾聽完結論，應該能回想起前面每個段落的要點

---

### Phase 4：主管審稿

模擬 VP/Director 角度審視初稿，找出潛在問題。

#### 審稿檢查清單

逐一檢查以下項目：

**1. 結論是否過強？**
- 標題的宣稱是否有足夠證據支持？
- 例：說「降低 80%」但素材只說「預估可降低」
- 修正方向：加上「預估」「初步測試顯示」「在特定條件下」

**2. 數字是否有來源？**
- 證據中的數字在素材中有明確提到嗎？
- 如果是推算的，有說明計算方式嗎？
- 修正方向：標注來源或說明計算

**3. 條件/範圍是否明確？**
- 適用於什麼場景？什麼情況下有效？
- 有什麼前提條件或限制？
- 修正方向：補充適用範圍

**4. 行動是否缺前提或風險？**
- 直接「全面採用」還是應該「先做 POC」？
- 有沒有潛在風險沒提到？
- 修正方向：加上前提條件或風險說明

**5. 術語是否讓國中生能懂？**
- 任何可能讓國中生看不懂的術語，都要加 `[[術語]]` 標記
- 標記的術語會自動連結到附錄的解釋和圖解
- 如果術語太多，考慮用白話文改寫

**6. 關鍵術語是否有解釋？（與 glossary.md 連動）**
- 報告中出現的專有名詞，讀者能理解它「是什麼」和「為何重要」嗎？
- 數字或指標有說明「代表什麼意義」嗎？
- **檢查 glossary.md 是否涵蓋所有 `[[術語]]` 標記**

**術語解釋自檢：**
```
對報告中每個專有名詞/機制/指標，問：
1. 它是什麼？（定義）
2. 它在這份報告中扮演什麼角色？（關聯性）
3. 讀者不懂這個詞，還能理解報告嗎？（必要性）
4. 是否已在 glossary.md 中有對應解釋？（附錄完整性）
```

**常見未解釋術語問題：**

| 問題模式 | 範例 | 修正方向 |
|----------|------|----------|
| 機制名稱無定義 | 「BufferTX 維持 2.2±0.4」 | 加入 glossary + 標記 `[[BufferTX]]` |
| 階段名稱無關聯 | 「UE5 五階段時間點」 | 在 glossary 說明「五階段用於預測下一幀完成時間」 |
| 指標無意義說明 | 「Jank 降低 80%」 | 加入 glossary 解釋「Jank = 掉幀次數」 |
| 縮寫無展開 | 「SF queue 機制」 | 加入 glossary 展開「SF = SurfaceFlinger」 |
| 已標記但無解釋 | `[[術語]]` 但 glossary 沒有 | 補充 glossary 條目 |

**修正原則：**
- 在 one_page.md 中用 `[[術語]]` 標記需解釋的詞
- 確保每個標記的術語都在 glossary.md 中有對應條目
- 所有術語都要用國中生能懂的白話文解釋
- 必要時加入圖解說明（在附錄中提供視覺化解釋）
- 附錄投影片會自動根據 glossary.md 產生

**7. 邏輯鏈是否完整？（最重要）**
- 從「已驗證成功要素」到「結論/行動」，每一步推論是否都有明確依據？
- 是否有「跳躍式結論」？（直接從問題跳到解法，沒解釋為何這個解法有效）
- 是否有「隱藏假設」？（推論依賴了沒說明的前提）

**邏輯鏈自檢流程：**
```
步驟 1：列出報告的推論鏈
   [前提 A] → [推論 B] → [推論 C] → [結論 D]

步驟 2：逐一檢查每個箭頭
   - A → B：為什麼 A 可以推出 B？有證據嗎？
   - B → C：為什麼 B 可以推出 C？有證據嗎？
   - C → D：為什麼 C 可以推出 D？有證據嗎？

步驟 3：標記斷鏈處
   - 如果某個箭頭無法解釋，標記為「邏輯斷鏈」
   - 必須補上說明或弱化結論
```

**常見邏輯斷鏈模式：**

| 斷鏈模式 | 範例 | 修正方向 |
|----------|------|----------|
| 類比跳躍 | 「PC 上有效 → 手機也會有效」 | 補充「因為 X 機制相同」或「需 POC 驗證」 |
| 數據跳躍 | 「測試 A 改善 20% → 全面採用」 | 補充「A 場景代表性」或「需更多場景驗證」 |
| 因果混淆 | 「同時發生 → 所以是原因」 | 補充因果機制說明或降級為「相關性」 |
| 選擇性引用 | 「只提有利數據」 | 補充限制條件或不利情況 |
| 規模跳躍 | 「小規模成功 → 大規模也行」 | 補充規模化考量或需階段驗證 |

**修正方向：**
- 補上缺失的推論步驟（用 [Cn] 引用素材）
- 明確說明假設前提
- 如果無法補齊，弱化結論：「初步顯示」「在 X 條件下」「仍需驗證」
- 最差情況：標記為「邏輯待補強」並建議做 POC

**8. 金字塔結構是否成立？**
- 報告中的所有內容，是否都指向標題宣稱的結論？
- 有沒有「離題內容」？（跟結論無關，放了也沒用）
- 有沒有「重複論點」？（兩個 bullet 說的是同一件事）
- 有沒有「缺漏論點」？（結論需要但沒提到的支撐）

**金字塔自檢流程：**
```
步驟 1：寫出標題結論
   「導入 Framepacing V2 可降低功耗 15% 且不影響流暢度」

步驟 2：列出報告中所有論點
   A. PC 平台已驗證有效
   B. BufferTX 機制可維持緩衝
   C. 手機 GPU 利用率偏低
   D. 預估可省 15% 功耗
   E. UE5 有五階段時間點

步驟 3：逐一檢查每個論點
   - A 支撐結論嗎？✓ 說明技術可行性
   - B 支撐結論嗎？✓ 說明機制原理
   - C 支撐結論嗎？✓ 說明問題現況
   - D 支撐結論嗎？✓ 直接支撐「降低功耗」
   - E 支撐結論嗎？✗ 跟結論什麼關係？

步驟 4：標記問題
   - E 是離題內容，需刪除或補上關聯說明
```

**常見金字塔問題：**

| 問題類型 | 症狀 | 修正方向 |
|----------|------|----------|
| 離題內容 | 論點跟結論無關 | 刪除，或補上「這跟結論的關係是...」 |
| 重複論點 | 兩個 bullet 說同一件事 | 合併，或區分角度 |
| 缺漏論點 | 結論需要但沒提 | 補上，或弱化結論 |
| 結論過大 | 論點撐不起結論 | 縮小結論範圍 |

**MECE 檢查（互斥且窮盡）：**
- 互斥：每個論點是否獨立？（不重複）
- 窮盡：支撐結論需要的論點是否都有了？（不遺漏）

**9. 演講稿邏輯是否一步接一步？（每輪必查）**

演講稿是口語表達，更容易出現邏輯跳躍。必須確保：
- 每一句話都承接上一句，聽眾能跟上思路
- 沒有「跳躍式敘述」（突然換話題，沒有過渡）
- 結論是前面所有段落的邏輯總結

**演講稿邏輯自檢流程：**
```
步驟 1：逐句檢查承接性
   將演講稿每一句編號，檢查：
   - 句 1 → 句 2：第 2 句是否承接第 1 句？
   - 句 2 → 句 3：第 3 句是否承接第 2 句？
   - ...依此類推

步驟 2：標記斷點
   - 如果某句話跟上一句沒有關聯，標記為「邏輯斷點」
   - 必須加入承接句或過渡詞

步驟 3：檢查結論完整性
   - 結論是否涵蓋了前面提到的所有要點？
   - 聽眾聽完結論，能否回想起整個論述過程？
```

**常見演講稿邏輯問題：**

| 問題類型 | 範例 | 修正方向 |
|----------|------|----------|
| 突然跳題 | 「功耗降低 15%。接下來談團隊配置。」 | 加入過渡：「有了這個效益，我們需要討論如何落地，這涉及團隊配置...」 |
| 結論脫節 | 結論沒提到前面說過的數據 | 結論要串起所有要點：「因為 X，透過 Y，達成 Z，所以建議 W」 |
| 缺少因果 | 「A 發生了。B 是解法。」 | 加入因果：「A 發生了，導致 C 問題，而 B 可以解決 C，所以 B 是解法。」 |
| 段落孤立 | 某段內容跟前後都沒關係 | 刪除該段，或加入關聯說明 |

**修正方向：**
- 加入承接詞：「因此」「這代表」「基於這點」「接下來」
- 加入過渡句：連接兩個不同主題
- 重寫結論：確保結論是所有論點的邏輯總和
- 如果無法連接，考慮刪除該段落

#### 產出 Issue List

將發現的問題整理成以下格式，並分類處理方式：

```markdown
## 審稿結果

我以主管角度審視了初稿，發現以下需要確認的問題：

### Q1：{問題標題}
- **類型**：{missing_evidence | ambiguity | inconsistency | decision_risk | undefined_term | logic_gap | pyramid_violation | script_logic_gap}
- **問題**：{具體描述問題}
- **位置**：{標題/證據/影響/行動/圖表/演講稿}
- **斷鏈分析**（如為 logic_gap 或 script_logic_gap）：
  - 推論鏈：{A} → {B} → {C}
  - 斷鏈處：{B} → {C}
  - 缺失：{缺少什麼才能連上}
- **處理**：{material | web_research | experiment | user_input}
- **建議**：{修正方向}

### Q2：{問題標題}
- **類型**：{類型}
- **問題**：{具體描述問題}
- **位置**：{位置}
- **處理**：{處理方式}
- **建議**：{修正方向}
```

**處理方式分類：**

| 處理方式 | 說明 | 動作 |
|----------|------|------|
| material | 素材內可回答 | 直接引用素材修正 |
| web_research | 需網路查證 | 進入 Phase 4.5 |
| experiment | 需實驗佐證 | 產出 Experiment Plan |
| user_input | 需使用者補充 | 詢問使用者 |

如果有 `web_research` 類型的 Issue，先進入 Phase 4.5。

---

### Phase 4.5：網路查證（如需要）

當有 Issue 需要網路查證時執行此步驟。

#### 查證流程

1. 使用 WebSearch 工具搜尋相關資訊：
   ```
   WebSearch: {關鍵字}
   ```

2. 使用 WebFetch 抓取 2-3 個可信來源的內容

3. 整理查證結果：

```markdown
## 網路查證結果

### {Issue Q1 關鍵字}

#### 來源 1：{source_title}
- **網址**：{url}
- **摘要**：{重點摘要}

#### 來源 2：{source_title}
- **網址**：{url}
- **摘要**：{重點摘要}

#### 結論
- **可信度**：support | conflict | unclear
- **說明**：{一致/衝突點說明}
- **建議處理**：{如何修正內容}
```

#### 查證結果使用規則

| 可信度 | 處理方式 |
|--------|----------|
| support | 可用於加強證據說明，但仍標注「業界資料顯示」 |
| conflict | 弱化結論，加註「有不同看法」或「仍需驗證」 |
| unclear | 保守處理，建議「先做 POC」驗證 |

**重要**：網路查證結果不能直接當作新證據，只能用於：
- 弱化/加條件
- 建議使用者補充
- 調整行動建議

---

### Phase 4.6：實驗計畫（缺數據或需實驗佐證時）

當符合以下條件時執行此步驟：
- 使用者選擇 E1 或 E2 佐證強度
- Issue 類型為 `experiment`（需實驗佐證）
- 審稿發現缺少關鍵數據

#### 產出 Experiment Plan

根據報告內容與缺少的佐證，產出**詳細的實驗計畫**。

**重要原則：**
- 實驗計畫必須讓國中生也能理解「為什麼要做這個實驗」
- **必須產生一張實驗流程圖**（加入 diagrams.md 的附錄圖）
- 主報告放摘要，詳細內容放附錄

```markdown
## 補充實驗計畫

本報告目前缺少以下關鍵數據，建議補做實驗：

### 實驗：{實驗名稱}

#### 為什麼需要這個實驗？（實驗原因）
{用白話文解釋，讓國中生也能懂}
- 目前報告宣稱：{報告中的結論或數據}
- 但缺少證據：{缺少什麼佐證}
- 如果不做實驗：{會有什麼風險，例如「結論可能不成立」}

#### 這個實驗要證明什麼？（實驗目的）
{明確說明實驗要驗證的假設}
- 假設：{如果 X 成立，那麼 Y 應該會發生}
- 成功標準：{什麼結果代表假設成立}
- 失敗標準：{什麼結果代表假設不成立}

#### 實驗設計（白話版）
{用國中生能懂的方式解釋實驗怎麼做}

**對照組（Baseline）**：
- 做什麼：{現行方案的操作}
- 為什麼需要對照組：{解釋比較的意義}

**實驗組（Experimental）**：
- 做什麼：{新方案的操作}
- 跟對照組的差異：{明確說明改變了什麼}

#### 實驗設定（技術細節）
- **裝置**：{型號/SoC}
- **版本**：{軟體版本號}
- **場景**：{測試場景/關卡}
- **時長**：{測試時長} 秒
- **重複次數**：{次數}（取平均值）

#### 量測指標
| 指標 | 單位 | 為什麼要測這個 | 成功門檻 |
|------|------|----------------|----------|
| {指標1} | {單位} | {白話解釋意義} | {例：>= 10%} |
| {指標2} | {單位} | {白話解釋意義} | {例：<= 5ms} |

#### 量測方法
{如何量測，使用什麼工具/指令}

#### 預期結果
- 如果假設成立：{預期會看到什麼}
- 如果假設不成立：{預期會看到什麼}

#### 回填表格
請完成實驗後，回填以下表格：

| Metric | Baseline | Experimental | Delta | 達標？ |
|--------|----------|--------------|-------|--------|
| {指標1} | | | | |
| {指標2} | | | | |

---

請完成實驗並回填數據，或選擇：
1. 提供實驗數據（回填上表）
2. 跳過實驗，弱化結論
3. 修改實驗設計
```

#### 實驗流程圖（必須產生）

每個實驗計畫都必須產生一張流程圖，加入 diagrams.md：

```markdown
## 附錄圖：{實驗名稱}流程圖

- **類型**：experiment_flow
- **說明**：完整描述實驗的執行流程和比較方式
- **尺寸**：1056x528

### SVG 生成指示

生成「實驗流程圖」，完整描述實驗設計：

**整體佈局**：上下兩區塊 + 右側比較區

**上方區塊「對照組 (Baseline)」**（灰色邊框）：
- 標題：🔵 對照組：{現行方案名稱}
- 流程節點（橫向）：
  1. {步驟1} → 2. {步驟2} → 3. {步驟3} → 結果：{預期結果}
- 每個節點要有具體內容，不只是「步驟1」

**下方區塊「實驗組 (Experimental)」**（藍色邊框）：
- 標題：🟢 實驗組：{新方案名稱}
- 流程節點（橫向）：
  1. {步驟1} → 2. {步驟2} → 3. {步驟3} → 結果：{預期結果}
- 用綠色標示跟對照組不同的步驟

**右側比較區**：
- 標題：📊 比較指標
- 列出要比較的指標和成功門檻
- 用表格或列表形式

**差異標註**：
- 用橙色虛線連接兩組的差異點
- 標註文字說明「這裡改變了 XXX」
```

#### E1 vs E2 差異

| 項目 | E1 輕佐證 | E2 強佐證 |
|------|----------|----------|
| 指標數量 | 1-2 個關鍵指標 | 3-5 個完整指標 |
| 場景數量 | 1 個代表場景 | 2-3 個不同場景 |
| 重複次數 | 1 次 | 3 次取平均 |
| 統計要求 | 無 | 標準差、信心區間 |
| 流程圖詳細度 | 簡化版（主要步驟） | 完整版（含子步驟） |

#### 處理使用者回填的數據

當使用者回填實驗數據後：
1. 自動計算 Delta（變化量/百分比）
2. 判斷是否達到成功門檻
3. 更新 one_page.md 中的證據區塊
4. 在 citations.md 中新增實驗來源
5. 更新實驗流程圖，加入實際結果

---

### Phase 4.7：詢問使用者

將需要使用者回答的問題整理後詢問：

```markdown
## 需要您確認的問題

### Q1：{問題標題}
- **問題**：{具體描述問題}
- **建議**：{修正方向}

請回答：
1. 同意修正建議
2. 提供補充資訊：{你的補充}
3. 維持原樣，原因：{你的原因}

### Q2：...
```

等待使用者回答後，進入 Phase 5。

---

### Phase 5：根據回饋重寫

根據使用者對 Issue List 的回答，修正初稿。

**修正策略：**

| 使用者回答 | 處理方式 |
|------------|----------|
| 同意修正 | 按建議修改 |
| 提供補充 | 整合新資訊後修改 |
| 維持原樣 | 保留，但考慮是否需加註條件 |

**禁止事項：**
- 不可硬撐沒有證據的結論
- 不可隱藏矛盾
- 不可在沒數字時寫具體百分比
- 不可忽略使用者提供的補充資訊

重新產生：
- one_page.md（修正版）
- diagram.md（如需調整）
- script.md（配合修正內容）

---

### Phase 5.5：多輪審稿迭代（如 MAX_ITERATIONS > 1）

當使用者設定多輪審稿時，重複 Phase 4 → Phase 5 流程。

#### 迭代邏輯

```
迭代計數 = 1

WHILE 迭代計數 <= MAX_ITERATIONS:
    執行 Phase 4（審稿）

    IF 審稿通過（無 Issue 或全部為 minor）:
        BREAK  # 進入 Phase 6

    IF 迭代計數 == MAX_ITERATIONS:
        強制保守輸出
        BREAK

    執行 Phase 4.5~4.7（查證/實驗/詢問）
    執行 Phase 5（重寫）
    迭代計數 += 1
```

#### 強制保守輸出（達到 MAX_ITERATIONS 仍有問題時）

當達到最大迭代次數但仍有未解決的 Issue 時：

1. **弱化所有未解決的宣稱**
   - 標題加「初步」「在特定條件下」
   - 數字加「約」「估計」
   - 結論加「仍需驗證」

2. **加入風險註記**
   ```markdown
   ## 風險與限制
   - {未解決 Issue 1}：{風險說明}
   - {未解決 Issue 2}：{風險說明}
   ```

3. **調整行動建議**
   - 「全面採用」→「建議先做 POC 驗證」
   - 「立即執行」→「待補充佐證後再決定」

4. **告知使用者**
   ```
   ⚠️ 注意：本報告經過 {N} 輪審稿，仍有以下問題未完全解決：
   - {Issue 1}
   - {Issue 2}

   已自動採取保守處理，建議：
   1. 補充更多佐證後再報告
   2. 或以目前保守版本先行報告，說明後續會補充
   ```

---

### Phase 6：渲染輸出

#### 6.1 建立輸出目錄

```bash
mkdir -p ./output
```

#### 6.2 儲存 diagrams.md 並產生 SVG

使用 **Task 工具調用 subagent** 生成 SVG 圖表。

1. 將 diagrams.md 內容儲存到 `./output/diagrams.md`

2. 對於 diagrams.md 中的**每個圖表區塊**，使用 Task 工具調用 subagent 生成 SVG：

**Task 工具調用方式：**

```
Task(
  description="生成{區塊名稱} SVG",
  subagent_type="general-purpose",
  prompt="""
你是 SVG 圖表生成專家。請根據以下指示生成 SVG 圖表。

## 規格
- 尺寸：{width} x {height} 像素（從 diagrams.md 的尺寸欄位取得）
- viewBox: "0 0 {width} {height}"
- 背景：白色 (#FFFFFF)
- 字型：font-family="Microsoft JhengHei, Arial, sans-serif"
- 配色：
  - 正面/改善後: #4CAF50 (綠)
  - 負面/改善前: #F44336 (紅)
  - 中性: #2196F3 (藍)
  - 區塊背景: #F5F5F5 (淺灰)
  - 邊框: #BDBDBD (深灰)
  - 文字: #333333

## 文字大小
- 區塊標題：font-size="18"
- 內容文字：font-size="14"
- 標籤/註解：font-size="12"

## 圖表內容
{從 diagrams.md 讀取的「SVG 生成指示」內容}

## 輸出
使用 Write 工具將完整 SVG 代碼寫入：./output/{output_filename}.svg
不要用 markdown 包裝，直接輸出純 SVG 代碼。
"""
)
```

3. **輸出檔案命名**：

| 區塊名稱 | 輸出檔案 |
|----------|----------|
| 主圖 | `./output/main_diagram.svg` |
| 附錄圖 1 | `./output/appendix_diagram_1.svg` |
| 附錄圖 2 | `./output/appendix_diagram_2.svg` |
| ... | ... |

4. **執行順序**：
   - 可以**並行**執行多個 Task 來加速生成
   - 每個 subagent 獨立生成一張 SVG

**錯誤處理**：如果某張圖生成失敗，記錄錯誤但繼續生成其他圖。

#### 6.3 產生 PPTX

這是最關鍵的步驟。你需要：

1. 讀取 `{skill_dir}/scripts/pptx_reference.py` 了解 python-pptx API 用法

2. 根據 one_page.md 的內容，動態產生 Python 程式碼

3. **佈局決策原則**：
   - 圖表與相關說明要放在一起
   - 根據內容量決定佈局（不要固定）
   - 證據多 → 可能需要左右分欄
   - 圖表複雜 → 給圖更多空間
   - 字體大小根據內容量調整（但不小於 10pt）
   - **有表格時**：表格放在投影片下方或右側，參考 pptx_reference.py 的 `add_table()` 函數

4. 將產生的程式碼儲存到 `./output/render_this.py`

5. 執行產生 PPTX：

```bash
cd ./output && python render_this.py
```

**render_this.py 的基本結構：**

```python
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RgbColor
from pptx.enum.text import PP_ALIGN
from pptx.enum.shapes import MSO_SHAPE

# 建立簡報
prs = Presentation()
prs.slide_width = Inches(13.333)
prs.slide_height = Inches(7.5)

# 加入空白投影片
slide = prs.slides.add_slide(prs.slide_layouts[6])

# === 根據內容動態產生以下程式碼 ===

# 標題
# ...

# 圖片
# ...

# 各區塊（背景、證據、影響、行動）
# ...

# === 加入演講稿到投影片備註 ===
speaker_notes = """
## 開場（看 TITLE）
{開場白內容}

## 說明背景（看 背景）
{背景說明內容}

## 說明流程/變化（看 DIAGRAM）
{圖表說明內容}

## 關鍵數據（看 證據）
{證據說明內容}

## 影響說明（看 影響）
{影響說明內容}

## 結論（看 行動）
{結論內容}
"""

notes_slide = slide.notes_slide
notes_slide.notes_text_frame.text = speaker_notes

# 儲存
prs.save('one_page.pptx')
print('Saved to one_page.pptx')
```

**重要**：演講稿內容必須嵌入到 `speaker_notes` 變數中，並透過 `slide.notes_slide.notes_text_frame.text` 寫入投影片備註。

#### 6.3.1 產生附錄投影片

根據 diagrams.md 和 glossary.md 的內容，產生附錄投影片。

**附錄投影片結構：**

```
投影片 1：主報告（one_page.md 內容 + 主圖）
投影片 2：附錄 - 流程圖詳解（如有附錄圖）
投影片 3：附錄 - 術語解釋（glossary.md 內容）
```

---

**附錄圖表投影片（投影片 2）**

當 diagrams.md 中有附錄圖時，產生圖表附錄投影片。

**佈局規則：**

| 附錄圖數量 | 佈局 | 每頁圖數 |
|-----------|------|---------|
| 1-2 張 | 上下排列 | 1-2 |
| 3-4 張 | 2x2 網格 | 4 |
| 5+ 張 | 分多頁，每頁 2x2 | 4 |

**render_this.py 圖表附錄投影片程式碼範例：**

```python
# === 附錄投影片 - 流程圖詳解 ===
appendix_diagrams = [
    ("PC vs 手機同步機制", "./appendix_diagram_1.svg", "比較兩平台的延遲控制機制"),
    ("Input-to-Display 延遲鏈路", "./appendix_diagram_2.svg", "完整的觸控到顯示時序"),
    ("BufferQueue 緩衝機制", "./appendix_diagram_3.svg", "Android 圖形管線的緩衝流程"),
    # ... 根據 diagrams.md 動態產生
]

if appendix_diagrams:
    # 計算需要幾頁
    diagrams_per_page = 4
    num_pages = (len(appendix_diagrams) + diagrams_per_page - 1) // diagrams_per_page

    for page in range(num_pages):
        diagram_slide = prs.slides.add_slide(prs.slide_layouts[6])

        # 標題
        page_label = f" ({page + 1}/{num_pages})" if num_pages > 1 else ""
        add_main_title(diagram_slide, f"附錄：流程圖詳解{page_label}", "報告中引用的完整流程圖")

        # 這一頁的圖表
        start_idx = page * diagrams_per_page
        end_idx = min(start_idx + diagrams_per_page, len(appendix_diagrams))
        page_diagrams = appendix_diagrams[start_idx:end_idx]

        # 根據圖數決定佈局
        num_diagrams = len(page_diagrams)
        if num_diagrams == 1:
            # 單圖：置中放大
            title, img_path, desc = page_diagrams[0]
            add_diagram_with_caption(diagram_slide, img_path, title, desc,
                                     left=1.0, top=1.2, width=11, height=5.5)
        elif num_diagrams == 2:
            # 兩圖：上下排列
            for i, (title, img_path, desc) in enumerate(page_diagrams):
                top = 1.2 + i * 3.2
                add_diagram_with_caption(diagram_slide, img_path, title, desc,
                                         left=0.5, top=top, width=12, height=2.8)
        else:
            # 3-4 圖：2x2 網格
            positions = [
                (0.3, 1.0, 6.3, 2.8),   # 左上
                (6.8, 1.0, 6.3, 2.8),   # 右上
                (0.3, 4.0, 6.3, 2.8),   # 左下
                (6.8, 4.0, 6.3, 2.8),   # 右下
            ]
            for i, (title, img_path, desc) in enumerate(page_diagrams):
                left, top, width, height = positions[i]
                add_diagram_with_caption(diagram_slide, img_path, title, desc,
                                         left=left, top=top, width=width, height=height)

def add_diagram_with_caption(slide, img_path, title, desc, left, top, width, height):
    """在投影片上加入圖表和說明文字"""
    from pptx.util import Inches, Pt

    # 圖表標題
    title_box = slide.shapes.add_textbox(Inches(left), Inches(top), Inches(width), Inches(0.3))
    tf = title_box.text_frame
    p = tf.paragraphs[0]
    p.text = title
    p.font.size = Pt(12)
    p.font.bold = True
    p.font.name = "Microsoft JhengHei"

    # 圖片（標題下方）
    try:
        slide.shapes.add_picture(img_path, Inches(left), Inches(top + 0.35), width=Inches(width), height=Inches(height - 0.7))
    except:
        # 如果圖片不存在，加入佔位文字
        placeholder = slide.shapes.add_textbox(Inches(left), Inches(top + 0.35), Inches(width), Inches(height - 0.7))
        placeholder.text_frame.paragraphs[0].text = f"[圖片載入失敗: {img_path}]"

    # 說明文字（圖片下方）
    desc_box = slide.shapes.add_textbox(Inches(left), Inches(top + height - 0.3), Inches(width), Inches(0.25))
    tf = desc_box.text_frame
    p = tf.paragraphs[0]
    p.text = desc
    p.font.size = Pt(9)
    p.font.color.rgb = RGBColor(100, 100, 100)
    p.font.name = "Microsoft JhengHei"
```

---

**術語解釋投影片（投影片 3）**

當 glossary.md 中有術語時，產生術語附錄投影片：

**術語超連結實作：**

1. **解析 `[[術語]]` 標記**：
   - 掃描 one_page.md 中所有 `[[術語]]` 標記
   - 記錄每個術語在主投影片上的位置（哪個 textbox、哪段文字）

2. **建立投影片內超連結**：
   - 使用 python-pptx 的 `add_hyperlink()` 方法
   - 連結目標：附錄投影片（slide 2）
   - 術語文字以底線標示（表示可點擊）

3. **附錄投影片佈局**：
   - 標題：「附錄：術語解釋」
   - 每個術語一個區塊，包含：
     - 術語名稱（粗體）
     - 白話解釋（用國中生能懂的方式，可多句）
     - 在本報告的角色
     - 類比說明（如有）

**render_this.py 的超連結程式碼範例：**

```python
from pptx.oxml.ns import qn
from pptx.oxml import parse_xml

# === 主投影片 (slide 1) ===
main_slide = prs.slides.add_slide(prs.slide_layouts[6])
# ... 主投影片內容 ...

# === 附錄投影片 (slide 2) ===
appendix_slide = prs.slides.add_slide(prs.slide_layouts[6])

# 附錄標題
add_main_title(appendix_slide, "附錄：術語解釋", "報告中專業術語的白話文解釋")

# 術語區塊（根據 glossary.md 動態產生）
glossary_items = [
    {
        "term": "L2 Cache",
        "category": "架構術語",
        "explanation": "處理器內的高速暫存記憶體，比主記憶體快 10-100 倍",
        "role": "跨 cluster 遷移會導致 L2 cache 內容失效，影響效能",
        "analogy": "像是書桌上的常用文件，比去檔案櫃拿快很多"
    },
    # ... 更多術語 ...
]

# 排列術語（2-3 欄佈局）
cols = 2 if len(glossary_items) <= 6 else 3
for i, item in enumerate(glossary_items):
    col = i % cols
    row = i // cols
    left = 0.25 + col * 4.3
    top = 0.85 + row * 2.2

    add_glossary_box(
        appendix_slide, left, top, 4.1, 2.0,
        item["term"], item["category"],
        item["explanation"], item["role"],
        item.get("analogy")
    )

# === 在主投影片建立超連結 ===
# 注意：python-pptx 的超連結支援有限，以下是變通方案

def add_term_with_link(text_frame, term, slide_index):
    """
    在文字框中添加帶超連結的術語

    變通方案：
    1. 術語以藍色底線標示
    2. 在術語後加上 [→附錄] 提示
    3. 附錄頁碼會標註在主投影片右下角
    """
    # 實作細節見 pptx_reference.py
    pass

# === 主投影片右下角加入附錄提示 ===
footer_box = main_slide.shapes.add_textbox(
    Inches(11), Inches(7.1), Inches(2), Inches(0.3)
)
tf = footer_box.text_frame
p = tf.paragraphs[0]
p.text = "術語解釋見附錄 (p.2)"
p.font.size = Pt(9)
p.font.color.rgb = RGBColor(100, 100, 100)
p.font.name = FONT_NAME
```

**術語標示方式（主投影片）：**

由於 PPTX 內部超連結支援有限，採用以下視覺標示：

| 標示方式 | 說明 |
|----------|------|
| 藍色文字 | 術語以藍色顯示，表示有解釋 |
| 上標數字 | 術語後加 `⁽¹⁾`，對應附錄編號 |
| 頁尾提示 | 主投影片右下角加「術語解釋見附錄」 |

**範例：**

主投影片文字：
```
降低跨 cluster⁽¹⁾ 的 migration⁽²⁾，可減少 L2 cache⁽³⁾ miss
```

附錄投影片：
```
⁽¹⁾ Cluster：一組共用 L2 cache 的處理器核心
⁽²⁾ Migration：作業系統將程式搬到另一組核心的動作
⁽³⁾ L2 Cache：處理器內的高速暫存記憶體
```

#### 6.4 輸出演講稿

將最終版 script.md 儲存到 `./output/speaker_script.md`

**注意**：演講稿會同時存在兩處：
1. PPTX 投影片的備註欄（方便簡報時直接看）
2. `./output/speaker_script.md` 獨立檔案（方便編輯或列印）

#### 6.5 輸出來源引用

將 Citation Map 儲存到 `./output/citations.md`，格式如下：

```markdown
# 來源引用清單

本報告引用的素材來源：

## C1
- **來源**：notes.md
- **位置**：第 1-5 行
- **原文**：Framepacing V2 透過SF queue來用部份延遲換部份功耗...
- **引用於**：已驗證的成功要素 - 第 1 點

## C2
- **來源**：notes.md
- **位置**：第 6-10 行
- **原文**：傳統方法透過拉高 CPU 頻率...
- **引用於**：已驗證的成功要素 - 第 2 點

...
```

#### 6.5.1 輸出術語詞彙表

將 glossary.md 儲存到 `./output/glossary.md`

#### 6.6 完成

告知使用者：

```
報告產生完成！

輸出檔案：
📊 ./output/one_page.pptx（投影片，含主報告 + 附錄術語解釋）
📝 ./output/speaker_script.md（演講稿獨立檔案）
🖼️ ./output/*.svg（圖表）
📚 ./output/citations.md（來源引用）
📖 ./output/glossary.md（術語詞彙表）

投影片結構：
- 第 1 頁：主報告（含術語上標標記）
- 第 2 頁：附錄 - 術語解釋（適合非技術背景讀者）

建議：
1. 開啟 PPTX 確認排版
2. 簡報時可開啟「簡報者檢視畫面」查看備註欄的演講稿
3. 如需調整，可以直接編輯 PPTX
4. 如被問「這數字哪來的？」，可查閱 citations.md
5. 如聽眾對術語有疑問，可切到附錄頁說明
```

---

## 錯誤處理

### SVG 生成失敗

如果 subagent 生成 SVG 失敗：

1. 檢查 SVG 生成指示是否清晰完整
2. 確認尺寸欄位格式正確（如 1056x528）
3. 如果仍失敗，簡化圖表內容後重試
4. 最後手段：改用 python-pptx shapes 畫簡單流程圖

### PPTX 渲染失敗

如果 render_this.py 執行失敗：

1. 檢查錯誤訊息
2. 修正程式碼後重新執行
3. 如果多次失敗，使用簡化佈局

### 素材不足

如果素材中缺少必要資訊：

1. 在審稿階段指出缺少什麼
2. 請使用者補充
3. 不可憑空捏造數據
